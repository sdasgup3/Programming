General
========
1. readonly  CProxy_Master name; // This name should not be mainchare
2. All the entry methods should be public
3. Add Worker(CkMigrateMessage*) {}
4. Given a CProxy_worker arra; you cannot do array[index].memberVar. The only way to get  a member var is to pass it using a entry method.
5. The place where we do mainProxy.entryM(); the control does not go to the mainchare, but instead it will call in asuynchronously and go ahead, so better make sure that the following code has a cleaner exit in case you do  not want to do anything else after calling mainchare entry method.
6. array [1D] Worker NOT chare [1D] ...
7. Worker(CkMigrateMessage* msg) {} //In C file only

SDAG
=====
1.  structure dagger entry method in ci file should end with semicolon
2.  handy to use wrap (x) ((x + n) %n) 
3.  for reduction with logical_and use int as the contributing elements
4.  Dont forget to the following
    ``` C++
    class Worker: public CBase_Worker {
      Worker_SDAG_CODE
      public:
    
        Worker() {
          __sdag_init();
        }

        void pup(PUP::er &p) {
          CBase_Worker::pup(p);
          __sdag_pup(p);
        }
    }
    ```
    
Reduction
=========
1. After the data is reduced, it is passed to you via a callback object. The message passed to the callback is of type CkReductionMsg . Unlike typed reductions, here we discuss callbacks that take CkReductionMsg* argument. The important members of CkReductionMsg are getSize() , which returns the number of bytes of reduction data; and getData() , which returns a ``void *'' to the actual reduced data. You may pass the client callback as an additional parameter to contribute .
```C++
    entry void myReductionEntry(CkReductionMsg* msg);    
    //In C
    double forces[2]=get_my_forces();
    CkCallback cb(CkIndex_myArrayType::myReductionEntry(NULL), thisProxy);
    contribute(2*sizeof(double), forces,CkReduction::sum_double, cb);
```   
```C++
    //For synchronisation purpose
    entry void myReductionEntry(CkReductionMsg* msg);    
    //In C
    CkCallback cb(CkIndex_myArrayType::myReductionEntry(NULL), thisProxy);
    contribute(cb);
```  
2. If no member passes a callback to contribute , the reduction will use the default callback. Programmers can set the default callback for an array or group using the **ckSetReductionClient(CkCallback*)** proxy call on **processor zero**, or by passing the callback to CkArrayOptions::setReductionClient() before creating the array. Again, a CkReductionMsg message will be passed to this callback, *which must delete the message when done*.
```C++
    CkCallback *cb = new CkCallback(CkIndex_Main::Result(NULL),  mainProxy); //Or
    CkCallback *cb = new CkCallback(CkReductionTarget(Main,done), thisProxy);// If Typed reduction
    cellProxy.ckSetReductionClient(cb);
```
3. As above, the client entry method of a reduction takes a single argument of type CkReductionMsg. However, by giving an entry method the reductiontarget attribute in the .ci file, you can instead use entry methods that take arguments of the same type as specified by the contribute call. When creating a callback to the reduction target, the entry method index is generated by CkReductionTarget(ChareClass, method_name) instead of CkIndex_ChareClass::method_name(...). 
```C++
    //In .ci
    entry [reductiontarget] void done(CkReductionMsg*);
    //In .C
    CkCallback cb(CkReductionTarget(mainChareClassName, entryMethod), mainProxy);   
    contribute(cb); // or
    contribute(sizeof(int),&myInt,CkReduction::sum_int, cb)
```
4. Sync reductions:
```C++
//In .ci
entry void done(CkReductionMsg* );
//In C
contribute(CkCallback(CkIndex_Main::done(NULL), mainproxy)); //OR
//In .ci
entry [reductiontarget] void barrierH();
//In C
contribute (CkCallback(CkReductionTarget(Worker,  barrierH), workerarray));
```

Threaded Entry Methods
===========================
1. 


To Dos
========
1. Quicense detection
2. Let e be an threaded entry method and we call e on an array of size 2 chares c0 and c1 and lets suppose there are scedules on the same core. Let the scheduler picks c0.e() and runs it. There will be  a thread t0 corresponding to the that entry method e. Now suppose that thread t0 call a sync method SM on c1. 
Is C1.SM a lead to a normal process or it will also generate a thread to run on the core?? 
Now t0 will suspend till it is awakened by the return of the sync method. 
c1.SM will be in the scheduler queue?? 
While t0 is suspended can a different entry method get scheduled??
If Yes, let c1.e gets scheduled and got suspended somehow...... then c1.SM gets shceduled...

1.  Charm++ basics: entry methods etc.Principle of Persistence
2. Chare Arrays
3. SDAG
4. Load balancing / LB Strategies (Greedy, refine, etc..) / PUP / Object Migration
5. Grain Size
6. Collective Communication: Reduction, reduction managers, callback, broadcast


7.  Quiescence detection
8. Threaded methods / Futures / Messages
9. Groups / Node groups
10. Charm++ tools: LiveViz, Projections, CharmDebug
11. Array Sections / Multicast
12. SMP Mode/CkLoop  
13. Cannon's Algorithm / Parallel Prefix

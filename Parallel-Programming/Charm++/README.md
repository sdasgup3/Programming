General
========
1. readonly  CProxy_Master name; // This name should not be mainchare
2. All the entry methods should be public
3. Add Worker(CkMigrateMessage*) {}
4. Given a CProxy_worker arra; you cannot do array[index].memberVar. The only way to get  a member var is to pass it using a entry method.
5. The place where we do mainProxy.entryM(); the control does not go to the mainchare, but instead it will call in asuynchronously and go ahead, so better make sure that the following code has a cleaner exit in case you do  not want to do anything else after calling mainchare entry method.

SDAG
=====
1.  structure dagger entry method in ci file should end with semicolon
2.  handy to use wrap (x) ((x + n) %n) 
3.  for reduction with logical_and use int as the contributing elements
4.  Dont forget to the following
    ``` C++
    class Worker: public CBase_Worker {
      Worker_SDAG_CODE
      public:
    
        Worker() {
          __sdag_init();
        }

        void pup(PUP::er &p) {
          CBase_Worker::pup(p);
          __sdag_pup(p);
        }
    }
    ```
    
Reduction
=========
1. After the data is reduced, it is passed to you via a callback object. The message passed to the callback is of type CkReductionMsg . Unlike typed reductions, here we discuss callbacks that take CkReductionMsg* argument. The important members of CkReductionMsg are getSize() , which returns the number of bytes of reduction data; and getData() , which returns a ``void *'' to the actual reduced data. You may pass the client callback as an additional parameter to contribute .
```C++
    entry void myReductionEntry(CkReductionMsg* msg);    
    //In C
    double forces[2]=get_my_forces();
    CkCallback cb(CkIndex_myArrayType::myReductionEntry(NULL), thisProxy);
    contribute(2*sizeof(double), forces,CkReduction::sum_double, cb);
```   
```C++
    //For synchronisation purpose
    entry void myReductionEntry(CkReductionMsg* msg);    
    //In C
    CkCallback cb(CkIndex_myArrayType::myReductionEntry(NULL), thisProxy);
    contribute(cb);
```  
2. If no member passes a callback to contribute , the reduction will use the default callback. Programmers can set the default callback for an array or group using the **ckSetReductionClient(CkCallback*)** proxy call on **processor zero**, or by passing the callback to CkArrayOptions::setReductionClient() before creating the array. Again, a CkReductionMsg message will be passed to this callback, *which must delete the message when done*.
```C++
    CkCallback *cb = new CkCallback(CkIndex_Main::Result(NULL),  mainProxy); //Or
    CkCallback *cb = new CkCallback(CkReductionTarget(Main,done), thisProxy);// If Typed reduction
    cellProxy.ckSetReductionClient(cb);
```
3. As above, the client entry method of a reduction takes a single argument of type CkReductionMsg. However, by giving an entry method the reductiontarget attribute in the .ci file, you can instead use entry methods that take arguments of the same type as specified by the contribute call. When creating a callback to the reduction target, the entry method index is generated by CkReductionTarget(ChareClass, method_name) instead of CkIndex_ChareClass::method_name(...). 
```C++
    //In .ci
    entry [reductiontarget] void done(CkReductionMsg*);
    //In .C
    CkCallback cb(CkReductionTarget(mainChareClassName, entryMethod), mainProxy);   
    contribute(cb); // or
    contribute(sizeof(int),&myInt,CkReduction::sum_int, cb)
```



To Dos
========
1. Quicense detection
2. 

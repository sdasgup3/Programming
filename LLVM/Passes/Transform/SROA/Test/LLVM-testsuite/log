===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

9 mem2reg    - Number of alloca's promoted with a single store
4 scalarrepl - Number of aggregates converted to scalar
4 scalarrepl - Number of allocas broken up
9 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of scalar allocas promoted to register

Diffing(2002-10-12-StructureArgs) 
4a5,6
> %struct.vec2 = type { double, double }
> 
10,14c12,32
<   %0 = bitcast double %S.coerce0 to i64
<   %1 = bitcast double %T.coerce0 to i64
<   %2 = bitcast i64 %0 to double
<   %3 = bitcast i64 %1 to double
<   %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([16 x i8]* @.str, i32 0, i32 0), double %2, double %S.coerce1, double %3, double %T.coerce1)
>   %S = alloca %struct.vec2, align 8
>   %T = alloca %struct.vec2, align 8
>   %0 = bitcast %struct.vec2* %S to { double, double }*
>   %1 = getelementptr { double, double }* %0, i32 0, i32 0
>   store double %S.coerce0, double* %1
>   %2 = getelementptr { double, double }* %0, i32 0, i32 1
>   store double %S.coerce1, double* %2
>   %3 = bitcast %struct.vec2* %T to { double, double }*
>   %4 = getelementptr { double, double }* %3, i32 0, i32 0
>   store double %T.coerce0, double* %4
>   %5 = getelementptr { double, double }* %3, i32 0, i32 1
>   store double %T.coerce1, double* %5
>   %X = getelementptr inbounds %struct.vec2* %S, i32 0, i32 0
>   %6 = load double* %X, align 8
>   %Y = getelementptr inbounds %struct.vec2* %S, i32 0, i32 1
>   %7 = load double* %Y, align 8
>   %X1 = getelementptr inbounds %struct.vec2* %T, i32 0, i32 0
>   %8 = load double* %X1, align 8
>   %Y2 = getelementptr inbounds %struct.vec2* %T, i32 0, i32 1
>   %9 = load double* %Y2, align 8
>   %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([16 x i8]* @.str, i32 0, i32 0), double %6, double %7, double %8, double %9)
23,25c41,61
<   %0 = bitcast i64 4602678819172646912 to double
<   call void @print(double %0, double 1.200000e+00, double %1, double 0x3FD5555555555555)
>   %U = alloca %struct.vec2, align 8
>   %V = alloca %struct.vec2, align 8
>   %X = getelementptr inbounds %struct.vec2* %U, i32 0, i32 0
>   %Y = getelementptr inbounds %struct.vec2* %U, i32 0, i32 1
>   store double 1.200000e+00, double* %Y, align 8
>   %X1 = getelementptr inbounds %struct.vec2* %V, i32 0, i32 0
>   %Y2 = getelementptr inbounds %struct.vec2* %V, i32 0, i32 1
>   store double 0x3FD5555555555555, double* %Y2, align 8
>   %0 = bitcast %struct.vec2* %U to { double, double }*
>   %1 = getelementptr { double, double }* %0, i32 0, i32 0
>   %2 = load double* %1, align 1
>   %3 = getelementptr { double, double }* %0, i32 0, i32 1
>   %4 = load double* %3, align 1
>   %5 = bitcast %struct.vec2* %V to { double, double }*
>   %6 = getelementptr { double, double }* %5, i32 0, i32 0
>   %7 = load double* %6, align 1
>   %8 = getelementptr { double, double }* %5, i32 0, i32 1
>   %9 = load double* %8, align 1
>   call void @print(double %2, double %4, double %7, double %9)
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

5 mem2reg    - Number of alloca's promoted with a single store
2 scalarrepl - Number of aggregates converted to scalar
2 scalarrepl - Number of allocas broken up
5 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of scalar allocas promoted to register

Diffing(2002-10-12-StructureArgsSimple) 
4a5,6
> %struct.vec2 = type { double, double }
> 
10,12c12,22
<   %0 = bitcast double %S.coerce0 to i64
<   %1 = bitcast i64 %0 to double
<   %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([8 x i8]* @.str, i32 0, i32 0), double %1, double %S.coerce1)
>   %S = alloca %struct.vec2, align 8
>   %0 = bitcast %struct.vec2* %S to { double, double }*
>   %1 = getelementptr { double, double }* %0, i32 0, i32 0
>   store double %S.coerce0, double* %1
>   %2 = getelementptr { double, double }* %0, i32 0, i32 1
>   store double %S.coerce1, double* %2
>   %X = getelementptr inbounds %struct.vec2* %S, i32 0, i32 0
>   %3 = load double* %X, align 8
>   %Y = getelementptr inbounds %struct.vec2* %S, i32 0, i32 1
>   %4 = load double* %Y, align 8
>   %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([8 x i8]* @.str, i32 0, i32 0), double %3, double %4)
21,22c31,41
<   %0 = bitcast i64 4602678819172646912 to double
<   call void @print(double %0, double 1.200000e+00)
>   %U = alloca %struct.vec2, align 8
>   %X = getelementptr inbounds %struct.vec2* %U, i32 0, i32 0
>   %Y = getelementptr inbounds %struct.vec2* %U, i32 0, i32 1
>   store double 1.200000e+00, double* %Y, align 8
>   %0 = bitcast %struct.vec2* %U to { double, double }*
>   %1 = getelementptr { double, double }* %0, i32 0, i32 0
>   %2 = load double* %1, align 1
>   %3 = getelementptr { double, double }* %0, i32 0, i32 1
>   %4 = load double* %3, align 1
>   call void @print(double %2, double %4)
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

 1 mem2reg    - Number of PHI nodes inserted
14 mem2reg    - Number of alloca's promoted with a single store
 1 scalarrepl - Number of aggregates converted to scalar
 4 scalarrepl - Number of allocas broken up
15 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of PHI nodes inserted
4 mem2reg    - Number of alloca's promoted with a single store
5 scalarrepl - Number of scalar allocas promoted to register

Diffing(2003-05-07-VarArgs) 
31a32,34
>   %dw = alloca %struct.DWordS_struct, align 4
>   %qw = alloca %struct.QuadWordS_struct, align 8
>   %ls = alloca %struct.LargeS_struct, align 8
245,250c248,256
<   %vaarg.addr74.0 = getelementptr inbounds %struct.DWordS_struct* %vaarg.addr74, i32 0, i32 0
<   %tmp8 = load i32* %vaarg.addr74.0, align 4
<   %vaarg.addr74.1 = getelementptr inbounds %struct.DWordS_struct* %vaarg.addr74, i32 0, i32 1
<   %tmp9 = load i8* %vaarg.addr74.1, align 4
<   %conv76 = sext i8 %tmp9 to i32
<   %call77 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([18 x i8]* @.str5, i32 0, i32 0), i32 %tmp8, i32 %conv76)
>   %39 = bitcast %struct.DWordS_struct* %dw to i8*
>   %40 = bitcast %struct.DWordS_struct* %vaarg.addr74 to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %39, i8* %40, i64 8, i32 4, i1 false)
>   %i = getelementptr inbounds %struct.DWordS_struct* %dw, i32 0, i32 0
>   %41 = load i32* %i, align 4
>   %c75 = getelementptr inbounds %struct.DWordS_struct* %dw, i32 0, i32 1
>   %42 = load i8* %c75, align 1
>   %conv76 = sext i8 %42 to i32
>   %call77 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([18 x i8]* @.str5, i32 0, i32 0), i32 %41, i32 %conv76)
261,262c267,268
<   %39 = and i1 %fits_in_gp82, %fits_in_fp85
<   br i1 %39, label %vaarg.in_reg86, label %vaarg.in_mem88
>   %43 = and i1 %fits_in_gp82, %fits_in_fp85
>   br i1 %43, label %vaarg.in_reg86, label %vaarg.in_mem88
265,282c271,288
<   %40 = getelementptr inbounds %struct.__va_list_tag* %arraydecay79, i32 0, i32 3
<   %reg_save_area87 = load i8** %40
<   %41 = bitcast %struct.QuadWordS_struct* %tmp to { i32, double }*
<   %42 = getelementptr i8* %reg_save_area87, i32 %gp_offset81
<   %43 = getelementptr i8* %reg_save_area87, i32 %fp_offset84
<   %44 = bitcast i8* %42 to i32*
<   %45 = load i32* %44
<   %46 = getelementptr inbounds { i32, double }* %41, i32 0, i32 0
<   store i32 %45, i32* %46
<   %47 = bitcast i8* %43 to double*
<   %48 = load double* %47
<   %49 = getelementptr inbounds { i32, double }* %41, i32 0, i32 1
<   store double %48, double* %49
<   %50 = bitcast { i32, double }* %41 to %struct.QuadWordS_struct*
<   %51 = add i32 %gp_offset81, 8
<   store i32 %51, i32* %gp_offset_p80
<   %52 = add i32 %fp_offset84, 16
<   store i32 %52, i32* %fp_offset_p83
>   %44 = getelementptr inbounds %struct.__va_list_tag* %arraydecay79, i32 0, i32 3
>   %reg_save_area87 = load i8** %44
>   %45 = bitcast %struct.QuadWordS_struct* %tmp to { i32, double }*
>   %46 = getelementptr i8* %reg_save_area87, i32 %gp_offset81
>   %47 = getelementptr i8* %reg_save_area87, i32 %fp_offset84
>   %48 = bitcast i8* %46 to i32*
>   %49 = load i32* %48
>   %50 = getelementptr inbounds { i32, double }* %45, i32 0, i32 0
>   store i32 %49, i32* %50
>   %51 = bitcast i8* %47 to double*
>   %52 = load double* %51
>   %53 = getelementptr inbounds { i32, double }* %45, i32 0, i32 1
>   store double %52, double* %53
>   %54 = bitcast { i32, double }* %45 to %struct.QuadWordS_struct*
>   %55 = add i32 %gp_offset81, 8
>   store i32 %55, i32* %gp_offset_p80
>   %56 = add i32 %fp_offset84, 16
>   store i32 %56, i32* %fp_offset_p83
288c294
<   %53 = bitcast i8* %overflow_arg_area90 to %struct.QuadWordS_struct*
>   %57 = bitcast i8* %overflow_arg_area90 to %struct.QuadWordS_struct*
294,299c300,308
<   %vaarg.addr93 = phi %struct.QuadWordS_struct* [ %50, %vaarg.in_reg86 ], [ %53, %vaarg.in_mem88 ]
<   %vaarg.addr93.0 = getelementptr inbounds %struct.QuadWordS_struct* %vaarg.addr93, i32 0, i32 0
<   %tmp6 = load i32* %vaarg.addr93.0, align 8
<   %vaarg.addr93.1 = getelementptr inbounds %struct.QuadWordS_struct* %vaarg.addr93, i32 0, i32 1
<   %tmp7 = load double* %vaarg.addr93.1, align 8
<   %call96 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([21 x i8]* @.str6, i32 0, i32 0), i32 %tmp6, double %tmp7)
>   %vaarg.addr93 = phi %struct.QuadWordS_struct* [ %54, %vaarg.in_reg86 ], [ %57, %vaarg.in_mem88 ]
>   %58 = bitcast %struct.QuadWordS_struct* %qw to i8*
>   %59 = bitcast %struct.QuadWordS_struct* %vaarg.addr93 to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %58, i8* %59, i64 16, i32 8, i1 false)
>   %i94 = getelementptr inbounds %struct.QuadWordS_struct* %qw, i32 0, i32 0
>   %60 = load i32* %i94, align 4
>   %d95 = getelementptr inbounds %struct.QuadWordS_struct* %qw, i32 0, i32 1
>   %61 = load double* %d95, align 8
>   %call96 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([21 x i8]* @.str6, i32 0, i32 0), i32 %60, double %61)
305a315
>   %62 = bitcast i8* %overflow_arg_area100 to %struct.LargeS_struct*
308,317c318,327
<   %overflow_arg_area1001 = bitcast i8* %overflow_arg_area100 to %struct.LargeS_struct*
<   %overflow_arg_area1001.0 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area1001, i32 0, i32 0
<   %tmp2 = load i32* %overflow_arg_area1001.0, align 8
<   %overflow_arg_area1001.1 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area1001, i32 0, i32 1
<   %tmp3 = load double* %overflow_arg_area1001.1, align 8
<   %overflow_arg_area1001.2 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area1001, i32 0, i32 2
<   %tmp4 = load %struct.DWordS_struct** %overflow_arg_area1001.2, align 8
<   %overflow_arg_area1001.3 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area1001, i32 0, i32 3
<   %tmp5 = load i32* %overflow_arg_area1001.3, align 8
<   %cmp = icmp ne %struct.DWordS_struct* %tmp4, null
>   %63 = bitcast %struct.LargeS_struct* %ls to i8*
>   %64 = bitcast %struct.LargeS_struct* %62 to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %63, i8* %64, i64 32, i32 8, i1 false)
>   %i102 = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 0
>   %65 = load i32* %i102, align 4
>   %d103 = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 1
>   %66 = load double* %d103, align 8
>   %ptr = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 2
>   %67 = load %struct.DWordS_struct** %ptr, align 8
>   %cmp = icmp ne %struct.DWordS_struct* %67, null
319c329,331
<   %call105 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([29 x i8]* @.str7, i32 0, i32 0), i32 %tmp2, double %tmp3, i32 %conv104, i32 %tmp5)
>   %j = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 3
>   %68 = load i32* %j, align 4
>   %call105 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([29 x i8]* @.str7, i32 0, i32 0), i32 %65, double %66, i32 %conv104, i32 %68)
349a362
>   %qw = alloca %struct.QuadWordS_struct, align 8
353,356c366,367
<   %main.qw.0 = getelementptr inbounds %struct.QuadWordS_struct* @main.qw, i32 0, i32 0
<   %tmp = load i32* %main.qw.0, align 8
<   %main.qw.1 = getelementptr inbounds %struct.QuadWordS_struct* @main.qw, i32 0, i32 1
<   %tmp1 = load double* %main.qw.1, align 8
>   %1 = bitcast %struct.QuadWordS_struct* %qw to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast (%struct.QuadWordS_struct* @main.qw to i8*), i64 16, i32 8, i1 false)
367,369c378,385
<   %1 = bitcast %struct.DWordS_struct* %dw to i64*
<   %2 = load i64* %1, align 1
<   call void (i8*, ...)* @test(i8* getelementptr inbounds ([4 x i8]* @.str13, i32 0, i32 0), i64 %2, i32 %tmp, double %tmp1, %struct.LargeS_struct* byval align 8 %ls)
>   %2 = bitcast %struct.DWordS_struct* %dw to i64*
>   %3 = load i64* %2, align 1
>   %4 = bitcast %struct.QuadWordS_struct* %qw to { i32, double }*
>   %5 = getelementptr { i32, double }* %4, i32 0, i32 0
>   %6 = load i32* %5, align 1
>   %7 = getelementptr { i32, double }* %4, i32 0, i32 1
>   %8 = load double* %7, align 1
>   call void (i8*, ...)* @test(i8* getelementptr inbounds ([4 x i8]* @.str13, i32 0, i32 0), i64 %3, i32 %6, double %8, %struct.LargeS_struct* byval align 8 %ls)
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

3 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of aggregates converted to scalar
3 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

2 mem2reg    - Number of alloca's promoted with a single store
2 scalarrepl - Number of scalar allocas promoted to register

Diffing(2003-05-21-UnionBitfields) 
4a5,7
> %union.anon = type { double }
> %struct.anon = type { i32, [4 x i8] }
> 
10,13c13,20
<   %0 = bitcast double %x to i64
<   %1 = lshr i64 %0, 32
<   %2 = trunc i64 %1 to i32
<   %bf.lshr = lshr i32 %2, 20
>   %u = alloca %union.anon, align 8
>   %d = bitcast %union.anon* %u to double*
>   store double %x, double* %d, align 8
>   %big_endian = bitcast %union.anon* %u to %struct.anon*
>   %exponent = getelementptr inbounds %struct.anon* %big_endian, i32 0, i32 1
>   %0 = bitcast [4 x i8]* %exponent to i32*
>   %bf.load = load i32* %0, align 4
>   %bf.lshr = lshr i32 %bf.load, 20
19,21c26,30
<   %3 = lshr i64 %0, 32
<   %4 = trunc i64 %3 to i32
<   %bf.clear3 = and i32 %4, 1048575
>   %big_endian1 = bitcast %union.anon* %u to %struct.anon*
>   %mantissa1 = getelementptr inbounds %struct.anon* %big_endian1, i32 0, i32 1
>   %1 = bitcast [4 x i8]* %mantissa1 to i32*
>   %bf.load2 = load i32* %1, align 4
>   %bf.clear3 = and i32 %bf.load2, 1048575
26,27c35,38
<   %5 = trunc i64 %0 to i32
<   %cmp6 = icmp eq i32 %5, 0
>   %big_endian5 = bitcast %union.anon* %u to %struct.anon*
>   %mantissa2 = getelementptr inbounds %struct.anon* %big_endian5, i32 0, i32 0
>   %2 = load i32* %mantissa2, align 4
>   %cmp6 = icmp eq i32 %2, 0
31,32c42,43
<   %6 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
<   %land.ext = zext i1 %6 to i32
>   %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
>   %land.ext = zext i1 %3 to i32
	G Log Pass
 	G Out Pass
 2003-05-21-UnionTest.c:4:45: warning: use of GNU old-style field designator extension [-Wgnu-designator]
  union { double __d; int __i[3]; } __u = { __d: __x };
                                            ^~~~
                                            .__d = 
1 warning generated.
===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

2 mem2reg    - Number of alloca's promoted with a single store
1 mem2reg    - Number of alloca's promoted within one block
1 scalarrepl - Number of aggregates converted to scalar
3 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

2 mem2reg    - Number of alloca's promoted with a single store
2 scalarrepl - Number of scalar allocas promoted to register

Diffing(2003-05-21-UnionTest) 
4a5,6
> %union.anon = type { double, [8 x i8] }
> 
10,16c12,18
<   %0 = bitcast double %__x to i64
<   %1 = zext i64 %0 to i128
<   %ins = or i128 %mask, %1
<   %2 = lshr i128 %ins, 32
<   %3 = trunc i128 %2 to i32
<   %cmp = icmp slt i32 %3, 0
>   %__u = alloca %union.anon, align 8
>   %__d = bitcast %union.anon* %__u to double*
>   store double %__x, double* %__d, align 8
>   %__i = bitcast %union.anon* %__u to [3 x i32]*
>   %arrayidx = getelementptr inbounds [3 x i32]* %__i, i32 0, i64 1
>   %0 = load i32* %arrayidx, align 4
>   %cmp = icmp slt i32 %0, 0
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

3 mem2reg    - Number of alloca's promoted with a single store
1 mem2reg    - Number of alloca's promoted within one block
2 scalarrepl - Number of allocas broken up
4 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

3 mem2reg    - Number of alloca's promoted with a single store
1 mem2reg    - Number of alloca's promoted within one block
1 mem2reg    - Number of dead alloca's removed
2 scalarrepl - Number of aggregate allocas broken up
5 scalarrepl - Number of scalar allocas promoted to register

Diffing(2003-05-22-LocalTypeTest) 
5a6,7
> %struct.sometimes = type { i32, i32 }
> %struct.sometimes.0 = type { i8 }
12a15,16
>   %S = alloca %struct.sometimes, align 4
>   %S3 = alloca %struct.sometimes.0, align 1
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

4 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of aggregates converted to scalar
3 scalarrepl - Number of allocas broken up
4 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

2 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of aggregate allocas broken up
2 scalarrepl - Number of scalar allocas promoted to register

Diffing(2003-05-23-TransparentUnion) 
4a5,6
> %union.UNION = type { float* }
> 
9a12
>   %U = alloca %union.UNION, align 8
18,21c21,32
<   %0 = ptrtoint i32* %I to i64
<   %1 = inttoptr i64 %0 to float*
<   %call = call i32 @try(float* %1)
<   %call3 = call i32 @try(float* %F)
>   %agg.tmp = alloca %union.UNION, align 8
>   %agg.tmp1 = alloca %union.UNION, align 8
>   %__iptr = bitcast %union.UNION* %agg.tmp to i32**
>   store i32* %I, i32** %__iptr, align 8
>   %coerce.dive = getelementptr %union.UNION* %agg.tmp, i32 0, i32 0
>   %0 = load float** %coerce.dive
>   %call = call i32 @try(float* %0)
>   %__fptr = bitcast %union.UNION* %agg.tmp1 to float**
>   store float* %F, float** %__fptr, align 8
>   %coerce.dive2 = getelementptr %union.UNION* %agg.tmp1, i32 0, i32 0
>   %1 = load float** %coerce.dive2
>   %call3 = call i32 @try(float* %1)
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

 1 mem2reg    - Number of PHI nodes inserted
17 mem2reg    - Number of alloca's promoted with a single store
 1 scalarrepl - Number of aggregates converted to scalar
 4 scalarrepl - Number of allocas broken up
18 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of PHI nodes inserted
7 mem2reg    - Number of alloca's promoted with a single store
8 scalarrepl - Number of scalar allocas promoted to register

Diffing(2003-08-11-VaListArg) 
29a30,32
>   %dw = alloca %struct.DWordS_struct, align 4
>   %qw = alloca %struct.QuadWordS_struct, align 8
>   %ls = alloca %struct.LargeS_struct, align 8
226,231c229,237
<   %vaarg.addr63.0 = getelementptr inbounds %struct.DWordS_struct* %vaarg.addr63, i32 0, i32 0
<   %tmp8 = load i32* %vaarg.addr63.0, align 4
<   %vaarg.addr63.1 = getelementptr inbounds %struct.DWordS_struct* %vaarg.addr63, i32 0, i32 1
<   %tmp9 = load i8* %vaarg.addr63.1, align 4
<   %conv65 = sext i8 %tmp9 to i32
<   %call66 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([18 x i8]* @.str5, i32 0, i32 0), i32 %tmp8, i32 %conv65)
>   %37 = bitcast %struct.DWordS_struct* %dw to i8*
>   %38 = bitcast %struct.DWordS_struct* %vaarg.addr63 to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %37, i8* %38, i64 8, i32 4, i1 false)
>   %i = getelementptr inbounds %struct.DWordS_struct* %dw, i32 0, i32 0
>   %39 = load i32* %i, align 4
>   %c64 = getelementptr inbounds %struct.DWordS_struct* %dw, i32 0, i32 1
>   %40 = load i8* %c64, align 1
>   %conv65 = sext i8 %40 to i32
>   %call66 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([18 x i8]* @.str5, i32 0, i32 0), i32 %39, i32 %conv65)
241,242c247,248
<   %37 = and i1 %fits_in_gp70, %fits_in_fp73
<   br i1 %37, label %vaarg.in_reg74, label %vaarg.in_mem76
>   %41 = and i1 %fits_in_gp70, %fits_in_fp73
>   br i1 %41, label %vaarg.in_reg74, label %vaarg.in_mem76
245,262c251,268
<   %38 = getelementptr inbounds %struct.__va_list_tag* %ap, i32 0, i32 3
<   %reg_save_area75 = load i8** %38
<   %39 = bitcast %struct.QuadWordS_struct* %tmp to { i32, double }*
<   %40 = getelementptr i8* %reg_save_area75, i32 %gp_offset69
<   %41 = getelementptr i8* %reg_save_area75, i32 %fp_offset72
<   %42 = bitcast i8* %40 to i32*
<   %43 = load i32* %42
<   %44 = getelementptr inbounds { i32, double }* %39, i32 0, i32 0
<   store i32 %43, i32* %44
<   %45 = bitcast i8* %41 to double*
<   %46 = load double* %45
<   %47 = getelementptr inbounds { i32, double }* %39, i32 0, i32 1
<   store double %46, double* %47
<   %48 = bitcast { i32, double }* %39 to %struct.QuadWordS_struct*
<   %49 = add i32 %gp_offset69, 8
<   store i32 %49, i32* %gp_offset_p68
<   %50 = add i32 %fp_offset72, 16
<   store i32 %50, i32* %fp_offset_p71
>   %42 = getelementptr inbounds %struct.__va_list_tag* %ap, i32 0, i32 3
>   %reg_save_area75 = load i8** %42
>   %43 = bitcast %struct.QuadWordS_struct* %tmp to { i32, double }*
>   %44 = getelementptr i8* %reg_save_area75, i32 %gp_offset69
>   %45 = getelementptr i8* %reg_save_area75, i32 %fp_offset72
>   %46 = bitcast i8* %44 to i32*
>   %47 = load i32* %46
>   %48 = getelementptr inbounds { i32, double }* %43, i32 0, i32 0
>   store i32 %47, i32* %48
>   %49 = bitcast i8* %45 to double*
>   %50 = load double* %49
>   %51 = getelementptr inbounds { i32, double }* %43, i32 0, i32 1
>   store double %50, double* %51
>   %52 = bitcast { i32, double }* %43 to %struct.QuadWordS_struct*
>   %53 = add i32 %gp_offset69, 8
>   store i32 %53, i32* %gp_offset_p68
>   %54 = add i32 %fp_offset72, 16
>   store i32 %54, i32* %fp_offset_p71
268c274
<   %51 = bitcast i8* %overflow_arg_area78 to %struct.QuadWordS_struct*
>   %55 = bitcast i8* %overflow_arg_area78 to %struct.QuadWordS_struct*
274,279c280,288
<   %vaarg.addr81 = phi %struct.QuadWordS_struct* [ %48, %vaarg.in_reg74 ], [ %51, %vaarg.in_mem76 ]
<   %vaarg.addr81.0 = getelementptr inbounds %struct.QuadWordS_struct* %vaarg.addr81, i32 0, i32 0
<   %tmp6 = load i32* %vaarg.addr81.0, align 8
<   %vaarg.addr81.1 = getelementptr inbounds %struct.QuadWordS_struct* %vaarg.addr81, i32 0, i32 1
<   %tmp7 = load double* %vaarg.addr81.1, align 8
<   %call84 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([21 x i8]* @.str6, i32 0, i32 0), i32 %tmp6, double %tmp7)
>   %vaarg.addr81 = phi %struct.QuadWordS_struct* [ %52, %vaarg.in_reg74 ], [ %55, %vaarg.in_mem76 ]
>   %56 = bitcast %struct.QuadWordS_struct* %qw to i8*
>   %57 = bitcast %struct.QuadWordS_struct* %vaarg.addr81 to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %56, i8* %57, i64 16, i32 8, i1 false)
>   %i82 = getelementptr inbounds %struct.QuadWordS_struct* %qw, i32 0, i32 0
>   %58 = load i32* %i82, align 4
>   %d83 = getelementptr inbounds %struct.QuadWordS_struct* %qw, i32 0, i32 1
>   %59 = load double* %d83, align 8
>   %call84 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([21 x i8]* @.str6, i32 0, i32 0), i32 %58, double %59)
284a294
>   %60 = bitcast i8* %overflow_arg_area87 to %struct.LargeS_struct*
287,296c297,306
<   %overflow_arg_area871 = bitcast i8* %overflow_arg_area87 to %struct.LargeS_struct*
<   %overflow_arg_area871.0 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area871, i32 0, i32 0
<   %tmp2 = load i32* %overflow_arg_area871.0, align 8
<   %overflow_arg_area871.1 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area871, i32 0, i32 1
<   %tmp3 = load double* %overflow_arg_area871.1, align 8
<   %overflow_arg_area871.2 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area871, i32 0, i32 2
<   %tmp4 = load %struct.DWordS_struct** %overflow_arg_area871.2, align 8
<   %overflow_arg_area871.3 = getelementptr inbounds %struct.LargeS_struct* %overflow_arg_area871, i32 0, i32 3
<   %tmp5 = load i32* %overflow_arg_area871.3, align 8
<   %cmp = icmp ne %struct.DWordS_struct* %tmp4, null
>   %61 = bitcast %struct.LargeS_struct* %ls to i8*
>   %62 = bitcast %struct.LargeS_struct* %60 to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %61, i8* %62, i64 32, i32 8, i1 false)
>   %i89 = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 0
>   %63 = load i32* %i89, align 4
>   %d90 = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 1
>   %64 = load double* %d90, align 8
>   %ptr = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 2
>   %65 = load %struct.DWordS_struct** %ptr, align 8
>   %cmp = icmp ne %struct.DWordS_struct* %65, null
298c308,310
<   %call92 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([29 x i8]* @.str7, i32 0, i32 0), i32 %tmp2, double %tmp3, i32 %conv91, i32 %tmp5)
>   %j = getelementptr inbounds %struct.LargeS_struct* %ls, i32 0, i32 3
>   %66 = load i32* %j, align 4
>   %call92 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([29 x i8]* @.str7, i32 0, i32 0), i32 %63, double %64, i32 %conv91, i32 %66)
305,306c317,318
<   %52 = bitcast %struct.__va_list_tag* %ap to i8*
<   call void @llvm.va_end(i8* %52)
>   %67 = bitcast %struct.__va_list_tag* %ap to i8*
>   call void @llvm.va_end(i8* %67)
366a379
>   %qw = alloca %struct.QuadWordS_struct, align 8
370,373c383,384
<   %main.qw.0 = getelementptr inbounds %struct.QuadWordS_struct* @main.qw, i32 0, i32 0
<   %tmp = load i32* %main.qw.0, align 8
<   %main.qw.1 = getelementptr inbounds %struct.QuadWordS_struct* @main.qw, i32 0, i32 1
<   %tmp1 = load double* %main.qw.1, align 8
>   %1 = bitcast %struct.QuadWordS_struct* %qw to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast (%struct.QuadWordS_struct* @main.qw to i8*), i64 16, i32 8, i1 false)
386,391c397,412
<   %1 = bitcast %struct.DWordS_struct* %dw to i64*
<   %2 = load i64* %1, align 1
<   call void (i8*, ...)* @testVaListArg(i8* getelementptr inbounds ([4 x i8]* @.str13, i32 0, i32 0), i64 %2, i32 %tmp, double %tmp1, %struct.LargeS_struct* byval align 8 %ls)
<   %3 = bitcast %struct.DWordS_struct* %dw to i64*
<   %4 = load i64* %3, align 1
<   call void (i8*, ...)* @testVaCopyArg(i8* getelementptr inbounds ([4 x i8]* @.str13, i32 0, i32 0), i64 %4, i32 %tmp, double %tmp1, %struct.LargeS_struct* byval align 8 %ls)
>   %2 = bitcast %struct.DWordS_struct* %dw to i64*
>   %3 = load i64* %2, align 1
>   %4 = bitcast %struct.QuadWordS_struct* %qw to { i32, double }*
>   %5 = getelementptr { i32, double }* %4, i32 0, i32 0
>   %6 = load i32* %5, align 1
>   %7 = getelementptr { i32, double }* %4, i32 0, i32 1
>   %8 = load double* %7, align 1
>   call void (i8*, ...)* @testVaListArg(i8* getelementptr inbounds ([4 x i8]* @.str13, i32 0, i32 0), i64 %3, i32 %6, double %8, %struct.LargeS_struct* byval align 8 %ls)
>   %9 = bitcast %struct.DWordS_struct* %dw to i64*
>   %10 = load i64* %9, align 1
>   %11 = bitcast %struct.QuadWordS_struct* %qw to { i32, double }*
>   %12 = getelementptr { i32, double }* %11, i32 0, i32 0
>   %13 = load i32* %12, align 1
>   %14 = getelementptr { i32, double }* %11, i32 0, i32 1
>   %15 = load double* %14, align 1
>   call void (i8*, ...)* @testVaCopyArg(i8* getelementptr inbounds ([4 x i8]* @.str13, i32 0, i32 0), i64 %10, i32 %13, double %15, %struct.LargeS_struct* byval align 8 %ls)
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

2 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of aggregates converted to scalar
1 scalarrepl - Number of allocas broken up
2 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of scalar allocas promoted to register

Diffing(2003-10-12-GlobalVarInitializers) 
15,20c15,22
<   %main.LocalUnion.0 = getelementptr inbounds %union.anon.0* @main.LocalUnion, i32 0, i32 0
<   %tmp = load i32* %main.LocalUnion.0, align 4
<   %0 = load float* bitcast (%union.anon* @GlobalUnion to float*), align 4
<   %conv = fpext float %0 to double
<   %1 = bitcast i32 %tmp to float
<   %conv1 = fpext float %1 to double
>   %LocalUnion = alloca %union.anon.0, align 4
>   %0 = bitcast %union.anon.0* %LocalUnion to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%union.anon.0* @main.LocalUnion to i8*), i64 4, i32 4, i1 false)
>   %1 = load float* bitcast (%union.anon* @GlobalUnion to float*), align 4
>   %conv = fpext float %1 to double
>   %__d = bitcast %union.anon.0* %LocalUnion to float*
>   %2 = load float* %__d, align 4
>   %conv1 = fpext float %2 to double
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

4 mem2reg    - Number of alloca's promoted with a single store
3 scalarrepl - Number of allocas broken up
4 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of scalar allocas promoted to register

Diffing(2004-02-03-AggregateCopy) 
4a5,6
> %struct.agg = type { i32 }
> 
10c12,29
<   %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([12 x i8]* @.str, i32 0, i32 0), i32 123, i32 123, i32 123)
>   %A = alloca %struct.agg, align 4
>   %B = alloca %struct.agg, align 4
>   %C = alloca %struct.agg, align 4
>   %X = getelementptr inbounds %struct.agg* %A, i32 0, i32 0
>   store i32 123, i32* %X, align 4
>   %0 = bitcast %struct.agg* %C to i8*
>   %1 = bitcast %struct.agg* %A to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 4, i32 4, i1 false)
>   %2 = bitcast %struct.agg* %B to i8*
>   %3 = bitcast %struct.agg* %C to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 4, i32 4, i1 false)
>   %X1 = getelementptr inbounds %struct.agg* %A, i32 0, i32 0
>   %4 = load i32* %X1, align 4
>   %X2 = getelementptr inbounds %struct.agg* %B, i32 0, i32 0
>   %5 = load i32* %X2, align 4
>   %X3 = getelementptr inbounds %struct.agg* %C, i32 0, i32 0
>   %6 = load i32* %X3, align 4
>   %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([12 x i8]* @.str, i32 0, i32 0), i32 %4, i32 %5, i32 %6)
	G Log Pass
 	G Out Pass
 2006-01-23-UnionInit.c:11:40: warning: use of GNU old-style field designator extension [-Wgnu-designator]
union task_union init_task_union = { { comm: "swapper" } };
                                       ^~~~~
                                       .comm = 
1 warning generated.
===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

16 mem2reg    - Number of alloca's promoted with a single store
 2 mem2reg    - Number of alloca's promoted within one block
 1 mem2reg    - Number of dead alloca's removed
 2 scalarrepl - Number of aggregates converted to scalar
 9 scalarrepl - Number of allocas broken up
19 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of scalar allocas promoted to register

Diffing(2006-01-23-UnionInit) 
14a15
> %union.ucast = type { %struct.s }
76,98c77,95
<   %ucast_test.y.0 = getelementptr inbounds %struct.s* @ucast_test.y, i32 0, i32 0
<   %tmp12 = load i32* %ucast_test.y.0, align 4
<   %ucast_test.y.1 = getelementptr inbounds %struct.s* @ucast_test.y, i32 0, i32 1
<   %tmp13 = load i32* %ucast_test.y.1, align 4
<   %ucast_test.y.2 = getelementptr inbounds %struct.s* @ucast_test.y, i32 0, i32 2
<   %tmp14 = load i32* %ucast_test.y.2, align 4
<   %0 = zext i32 %tmp12 to i128
<   %ins25 = or i128 %mask24, %0
<   %1 = zext i32 %tmp13 to i128
<   %2 = shl i128 %1, 32
<   %ins22 = or i128 %mask21, %2
<   %3 = zext i32 %tmp14 to i128
<   %4 = shl i128 %3, 64
<   %ins = or i128 %mask, %4
<   %5 = trunc i128 %ins to i64
<   %6 = insertvalue { i64, i32 } undef, i64 %5, 0
<   %7 = lshr i128 %ins, 64
<   %8 = trunc i128 %7 to i32
<   %9 = insertvalue { i64, i32 } %6, i32 %8, 1
<   ret { i64, i32 } %9
>   %retval = alloca %union.ucast, align 4
>   %y = alloca %struct.s, align 4
>   %z = alloca %union.ucast, align 4
>   %tmp = alloca { i64, i32 }
>   %0 = bitcast %struct.s* %y to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.s* @ucast_test.y to i8*), i64 12, i32 4, i1 false)
>   %1 = bitcast %union.ucast* %z to %struct.s*
>   %2 = bitcast %struct.s* %1 to i8*
>   %3 = bitcast %struct.s* %y to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 12, i32 4, i1 false)
>   %4 = bitcast %union.ucast* %retval to i8*
>   %5 = bitcast %union.ucast* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 12, i32 4, i1 false)
>   %coerce.dive = getelementptr %union.ucast* %retval, i32 0, i32 0
>   %6 = bitcast { i64, i32 }* %tmp to i8*
>   %7 = bitcast %struct.s* %coerce.dive to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 12, i32 1, i1 false)
>   %8 = load { i64, i32 }* %tmp
>   ret { i64, i32 } %8
103a101
>   %XX = alloca %union.ucast, align 4
105a104,106
>   %undef.agg.tmp = alloca %struct.emptystruct, align 1
>   %coerce = alloca %union.ucast, align 4
>   %tmp = alloca { i64, i32 }
159,179c160,185
<   %24 = extractvalue { i64, i32 } %call20, 0
<   %25 = zext i64 %24 to i128
<   %ins = or i128 %mask, %25
<   %26 = extractvalue { i64, i32 } %call20, 1
<   %27 = zext i32 %26 to i128
<   %28 = shl i128 %27, 64
<   %ins11 = or i128 %mask10, %28
<   %29 = trunc i128 %ins11 to i32
<   %30 = lshr i128 %ins11, 32
<   %31 = trunc i128 %30 to i32
<   %32 = lshr i128 %ins11, 64
<   %33 = trunc i128 %32 to i32
<   %call23 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([22 x i8]* @.str11, i32 0, i32 0), i32 %29, i32 %31, i32 %33, i32 %29)
<   %34 = load i16* getelementptr inbounds (%struct.foo2* @foo2, i32 0, i32 0), align 2
<   %conv24 = sext i16 %34 to i32
<   %35 = load i64* getelementptr inbounds (%struct.foo2* @foo2, i32 0, i32 2), align 4
<   %conv25 = trunc i64 %35 to i32
<   %36 = load i16* getelementptr inbounds (%struct.foo2* @foo2, i32 0, i32 3), align 2
<   %conv26 = sext i16 %36 to i32
>   %coerce.dive = getelementptr %union.ucast* %coerce, i32 0, i32 0
>   store { i64, i32 } %call20, { i64, i32 }* %tmp
>   %24 = bitcast { i64, i32 }* %tmp to i8*
>   %25 = bitcast %struct.s* %coerce.dive to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %24, i64 12, i32 1, i1 false)
>   %26 = bitcast %union.ucast* %XX to i8*
>   %27 = bitcast %union.ucast* %coerce to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %27, i64 12, i32 4, i1 false)
>   %s = bitcast %union.ucast* %XX to %struct.s*
>   %i1 = getelementptr inbounds %struct.s* %s, i32 0, i32 0
>   %28 = load i32* %i1, align 4
>   %s21 = bitcast %union.ucast* %XX to %struct.s*
>   %i2 = getelementptr inbounds %struct.s* %s21, i32 0, i32 1
>   %29 = load i32* %i2, align 4
>   %s22 = bitcast %union.ucast* %XX to %struct.s*
>   %i3 = getelementptr inbounds %struct.s* %s22, i32 0, i32 2
>   %30 = load i32* %i3, align 4
>   %i = bitcast %union.ucast* %XX to i32*
>   %31 = load i32* %i, align 4
>   %call23 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([22 x i8]* @.str11, i32 0, i32 0), i32 %28, i32 %29, i32 %30, i32 %31)
>   %32 = load i16* getelementptr inbounds (%struct.foo2* @foo2, i32 0, i32 0), align 2
>   %conv24 = sext i16 %32 to i32
>   %33 = load i64* getelementptr inbounds (%struct.foo2* @foo2, i32 0, i32 2), align 4
>   %conv25 = trunc i64 %33 to i32
>   %34 = load i16* getelementptr inbounds (%struct.foo2* @foo2, i32 0, i32 3), align 2
>   %conv26 = sext i16 %34 to i32
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

4 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of allocas broken up
4 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

3 mem2reg    - Number of alloca's promoted with a single store
3 scalarrepl - Number of scalar allocas promoted to register

Diffing(2007-04-10-BitfieldTest) 
4a5,7
> %union.u = type { i64 }
> %struct.anon = type { [8 x i8] }
> 
10c13,19
<   %bf.lshr = lshr i64 82351535429844991, 48
>   %uu = alloca %union.u, align 8
>   %token = bitcast %union.u* %uu to i64*
>   store i64 82351535429844991, i64* %token, align 8
>   %s = bitcast %union.u* %uu to %struct.anon*
>   %0 = bitcast %struct.anon* %s to i64*
>   %bf.load = load i64* %0, align 4
>   %bf.lshr = lshr i64 %bf.load, 48
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

14 mem2reg    - Number of alloca's promoted with a single store
 1 mem2reg    - Number of alloca's promoted within one block
 2 scalarrepl - Number of aggregates converted to scalar
 6 scalarrepl - Number of allocas broken up
15 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

5 mem2reg    - Number of alloca's promoted with a single store
5 scalarrepl - Number of scalar allocas promoted to register

Diffing(2009-12-07-StructReturn) 
28,39c28,37
<   %foobify.my_static_foo2 = bitcast %struct.barstruct* @foobify.my_static_foo to [3 x float]*
<   %foobify.my_static_foo2.0 = getelementptr inbounds [3 x float]* %foobify.my_static_foo2, i32 0, i32 0
<   %tmp3 = load float* %foobify.my_static_foo2.0, align 4
<   %foobify.my_static_foo2.1 = getelementptr inbounds [3 x float]* %foobify.my_static_foo2, i32 0, i32 1
<   %tmp4 = load float* %foobify.my_static_foo2.1, align 4
<   %foobify.my_static_foo2.2 = getelementptr inbounds [3 x float]* %foobify.my_static_foo2, i32 0, i32 2
<   %tmp5 = load float* %foobify.my_static_foo2.2, align 4
<   %0 = insertelement <2 x float> undef, float %tmp3, i32 0
<   %1 = insertelement <2 x float> %0, float %tmp4, i32 1
<   %insert = insertvalue { <2 x float>, float } undef, <2 x float> %1, 0
<   %insert11 = insertvalue { <2 x float>, float } %insert, float %tmp5, 1
<   ret { <2 x float>, float } %insert11
>   %retval = alloca %struct.foostruct, align 4
>   %tmp = alloca { <2 x float>, float }
>   %0 = bitcast %struct.foostruct* %retval to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.barstruct* @foobify.my_static_foo to i8*), i64 12, i32 4, i1 false)
>   %coerce.dive = getelementptr %struct.foostruct* %retval, i32 0, i32 0
>   %1 = bitcast { <2 x float>, float }* %tmp to i8*
>   %2 = bitcast [3 x float]* %coerce.dive to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 12, i32 1, i1 false)
>   %3 = load { <2 x float>, float }* %tmp
>   ret { <2 x float>, float } %3
47a46,47
>   %coerce = alloca %struct.foostruct, align 4
>   %tmp = alloca { <2 x float>, float }
50,62c50,58
<   %call110 = extractvalue { <2 x float>, float } %call1, 0
<   %call111 = extractvalue { <2 x float>, float } %call1, 1
<   %0 = extractelement <2 x float> %call110, i32 0
<   %1 = extractelement <2 x float> %call110, i32 1
<   %bar_ary6 = bitcast [4 x %struct.barstruct]* @bar_ary to [3 x float]*
<   %bar_ary6.0 = getelementptr inbounds [3 x float]* %bar_ary6, i32 0, i32 0
<   store float %0, float* %bar_ary6.0, align 4
<   %bar_ary6.1 = getelementptr inbounds [3 x float]* %bar_ary6, i32 0, i32 1
<   store float %1, float* %bar_ary6.1, align 4
<   %bar_ary6.2 = getelementptr inbounds [3 x float]* %bar_ary6, i32 0, i32 2
<   store float %call111, float* %bar_ary6.2, align 4
<   %2 = load float* %call, align 4
<   %conv = fpext float %2 to double
>   %coerce.dive = getelementptr %struct.foostruct* %coerce, i32 0, i32 0
>   store { <2 x float>, float } %call1, { <2 x float>, float }* %tmp
>   %0 = bitcast { <2 x float>, float }* %tmp to i8*
>   %1 = bitcast [3 x float]* %coerce.dive to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %0, i64 12, i32 1, i1 false)
>   %2 = bitcast %struct.foostruct* %coerce to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast ([4 x %struct.barstruct]* @bar_ary to i8*), i8* %2, i64 12, i32 4, i1 false)
>   %3 = load float* %call, align 4
>   %conv = fpext float %3 to double
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

5 mem2reg    - Number of alloca's promoted with a single store
1 scalarrepl - Number of aggregates converted to scalar
5 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

4 mem2reg    - Number of alloca's promoted with a single store
4 scalarrepl - Number of scalar allocas promoted to register

Diffing(2010-05-24-BitfieldTest) 
4a5,7
> %union.ia32_mcg_cap_t = type { i64 }
> %struct.anon = type { [2 x i8], [6 x i8] }
> 
12,13c15,21
<   %0 = trunc i64 2054 to i16
<   %bf.lshr = lshr i16 %0, 8
>   %ia32_mcg_cap = alloca %union.ia32_mcg_cap_t, align 8
>   %u64 = bitcast %union.ia32_mcg_cap_t* %ia32_mcg_cap to i64*
>   store i64 2054, i64* %u64, align 8
>   %bits = bitcast %union.ia32_mcg_cap_t* %ia32_mcg_cap to %struct.anon*
>   %0 = bitcast %struct.anon* %bits to i16*
>   %bf.load = load i16* %0, align 8
>   %bf.lshr = lshr i16 %bf.load, 8
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

13 mem2reg    - Number of alloca's promoted with a single store
 2 mem2reg    - Number of alloca's promoted within one block
 1 mem2reg    - Number of dead alloca's removed
 7 scalarrepl - Number of allocas broken up
16 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

1 mem2reg    - Number of alloca's promoted with a single store
2 mem2reg    - Number of alloca's promoted within one block
1 scalarrepl - Number of aggregate allocas broken up
3 scalarrepl - Number of scalar allocas promoted to register

Diffing(conditional-gnu-ext) 
10,14c10,15
<   %0 = trunc i64 %val.coerce to i32
<   %sroa.store.elt = lshr i64 %val.coerce, 32
<   %1 = trunc i64 %sroa.store.elt to i32
<   %2 = load i32* @getComplex.count, align 4
<   %inc = add nsw i32 %2, 1
>   %retval = alloca { i32, i32 }, align 4
>   %val = alloca { i32, i32 }, align 8
>   %0 = bitcast { i32, i32 }* %val to i64*
>   store i64 %val.coerce, i64* %0, align 1
>   %1 = load i32* @getComplex.count, align 4
>   %inc = add nsw i32 %1, 1
16c17
<   %tobool = icmp ne i32 %2, 0
>   %tobool = icmp ne i32 %1, 0
24,28c25,35
<   %3 = zext i32 %0 to i64
<   %4 = zext i32 %1 to i64
<   %5 = shl i64 %4, 32
<   %6 = or i64 %5, %3
<   ret i64 %6
>   %val.realp = getelementptr inbounds { i32, i32 }* %val, i32 0, i32 0
>   %val.real = load i32* %val.realp, align 4
>   %val.imagp = getelementptr inbounds { i32, i32 }* %val, i32 0, i32 1
>   %val.imag = load i32* %val.imagp, align 4
>   %real = getelementptr inbounds { i32, i32 }* %retval, i32 0, i32 0
>   %imag = getelementptr inbounds { i32, i32 }* %retval, i32 0, i32 1
>   store i32 %val.real, i32* %real, align 4
>   store i32 %val.imag, i32* %imag, align 4
>   %2 = bitcast { i32, i32 }* %retval to i64*
>   %3 = load i64* %2, align 1
>   ret i64 %3
37,46c44,63
<   %0 = zext i32 1 to i64
<   %1 = zext i32 2 to i64
<   %2 = shl i64 %1, 32
<   %3 = or i64 %2, %0
<   %call = call i64 @getComplex(i64 %3)
<   %4 = trunc i64 %call to i32
<   %sroa.store.elt = lshr i64 %call, 32
<   %5 = trunc i64 %sroa.store.elt to i32
<   %tobool = icmp ne i32 %4, 0
<   %tobool2 = icmp ne i32 %5, 0
>   %retval = alloca { i32, i32 }, align 4
>   %cond = alloca { i32, i32 }, align 4
>   %rhs = alloca { i32, i32 }, align 4
>   %coerce = alloca { i32, i32 }, align 4
>   %coerce1 = alloca { i32, i32 }, align 4
>   %real = getelementptr inbounds { i32, i32 }* %coerce, i32 0, i32 0
>   %imag = getelementptr inbounds { i32, i32 }* %coerce, i32 0, i32 1
>   store i32 1, i32* %real, align 4
>   store i32 2, i32* %imag, align 4
>   %0 = bitcast { i32, i32 }* %coerce to i64*
>   %1 = load i64* %0, align 1
>   %call = call i64 @getComplex(i64 %1)
>   %2 = bitcast { i32, i32 }* %coerce1 to i64*
>   store i64 %call, i64* %2, align 1
>   %coerce1.realp = getelementptr inbounds { i32, i32 }* %coerce1, i32 0, i32 0
>   %coerce1.real = load i32* %coerce1.realp, align 4
>   %coerce1.imagp = getelementptr inbounds { i32, i32 }* %coerce1, i32 0, i32 1
>   %coerce1.imag = load i32* %coerce1.imagp, align 4
>   %tobool = icmp ne i32 %coerce1.real, 0
>   %tobool2 = icmp ne i32 %coerce1.imag, 0
57,63c74,82
<   %cond.r = phi i32 [ %4, %cond.true ], [ undef, %cond.false ]
<   %cond.i = phi i32 [ %5, %cond.true ], [ undef, %cond.false ]
<   %6 = zext i32 %cond.r to i64
<   %7 = zext i32 %cond.i to i64
<   %8 = shl i64 %7, 32
<   %9 = or i64 %8, %6
<   ret i64 %9
>   %cond.r = phi i32 [ %coerce1.real, %cond.true ], [ undef, %cond.false ]
>   %cond.i = phi i32 [ %coerce1.imag, %cond.true ], [ undef, %cond.false ]
>   %real4 = getelementptr inbounds { i32, i32 }* %retval, i32 0, i32 0
>   %imag5 = getelementptr inbounds { i32, i32 }* %retval, i32 0, i32 1
>   store i32 %cond.r, i32* %real4, align 4
>   store i32 %cond.i, i32* %imag5, align 4
>   %3 = bitcast { i32, i32 }* %retval to i64*
>   %4 = load i64* %3, align 1
>   ret i64 %4
68a88
>   %coerce = alloca { i32, i32 }, align 4
70,72c90,95
<   %0 = trunc i64 %call to i32
<   %sroa.store.elt = lshr i64 %call, 32
<   %1 = trunc i64 %sroa.store.elt to i32
>   %0 = bitcast { i32, i32 }* %coerce to i64*
>   store i64 %call, i64* %0, align 1
>   %coerce.realp = getelementptr inbounds { i32, i32 }* %coerce, i32 0, i32 0
>   %coerce.real = load i32* %coerce.realp, align 4
>   %coerce.imagp = getelementptr inbounds { i32, i32 }* %coerce, i32 0, i32 1
>   %coerce.imag = load i32* %coerce.imagp, align 4
	G Log Pass
 	G Out Pass
 ===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

 1 mem2reg    - Number of PHI nodes inserted
91 mem2reg    - Number of alloca's promoted with a single store
21 scalarrepl - Number of allocas broken up
92 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

 1 mem2reg    - Number of PHI nodes inserted
21 mem2reg    - Number of alloca's promoted with a single store
22 scalarrepl - Number of scalar allocas promoted to register

Diffing(ms_struct_pack_layout) 
19a20,29
>   %test_one = alloca %struct.one, align 4
>   %test_two = alloca %struct.two, align 4
>   %test_three = alloca %struct.three, align 2
>   %test_four = alloca %struct.four, align 4
>   %test_five = alloca %struct.five, align 1
>   %test_six = alloca %struct.six, align 4
>   %test_seven = alloca %struct.seven, align 1
>   %test_eight = alloca %struct.eight, align 2
>   %test_nine = alloca %union.nine, align 8
>   %test_ten = alloca %struct.ten, align 8
39,52c49,54
<   %filler74 = bitcast [16 x i8]* %filler to %struct.one*
<   %filler74.0 = getelementptr inbounds %struct.one* %filler74, i32 0, i32 0
<   %tmp75 = load i32* %filler74.0, align 4
<   %filler74.1 = getelementptr inbounds %struct.one* %filler74, i32 0, i32 1
<   %tmp76 = load i8* %filler74.1, align 4
<   %filler74.2 = getelementptr inbounds %struct.one* %filler74, i32 0, i32 2
<   %tmp77 = load i8* %filler74.2, align 1
<   %filler74.3 = getelementptr inbounds %struct.one* %filler74, i32 0, i32 3
<   %tmp78 = load i8* %filler74.3, align 2
<   %filler74.4 = getelementptr inbounds %struct.one* %filler74, i32 0, i32 4
<   %tmp79 = load i8* %filler74.4, align 1
<   %filler74.5 = getelementptr inbounds %struct.one* %filler74, i32 0, i32 5
<   %tmp80 = load i8* %filler74.5, align 4
<   %conv2 = sext i8 %tmp80 to i32
>   %0 = bitcast %struct.one* %test_one to i8*
>   %1 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 12, i32 4, i1 false)
>   %c = getelementptr inbounds %struct.one* %test_one, i32 0, i32 5
>   %2 = load i8* %c, align 1
>   %conv2 = sext i8 %2 to i32
62,85c64,69
<   %filler63 = bitcast [16 x i8]* %filler to %struct.two*
<   %filler63.0 = getelementptr inbounds %struct.two* %filler63, i32 0, i32 0
<   %tmp64 = load i32* %filler63.0, align 4
<   %filler63.1 = getelementptr inbounds %struct.two* %filler63, i32 0, i32 1
<   %tmp65 = load i8* %filler63.1, align 4
<   %filler63.2 = getelementptr inbounds %struct.two* %filler63, i32 0, i32 2
<   %filler63.2.0 = getelementptr inbounds [3 x i8]* %filler63.2, i32 0, i32 0
<   %tmp71 = load i8* %filler63.2.0, align 1
<   %filler63.2.1 = getelementptr inbounds [3 x i8]* %filler63.2, i32 0, i32 1
<   %tmp72 = load i8* %filler63.2.1, align 1
<   %filler63.2.2 = getelementptr inbounds [3 x i8]* %filler63.2, i32 0, i32 2
<   %tmp73 = load i8* %filler63.2.2, align 1
<   %filler63.3 = getelementptr inbounds %struct.two* %filler63, i32 0, i32 3
<   %tmp66 = load i8* %filler63.3, align 4
<   %filler63.4 = getelementptr inbounds %struct.two* %filler63, i32 0, i32 4
<   %filler63.4.0 = getelementptr inbounds [3 x i8]* %filler63.4, i32 0, i32 0
<   %tmp68 = load i8* %filler63.4.0, align 1
<   %filler63.4.1 = getelementptr inbounds [3 x i8]* %filler63.4, i32 0, i32 1
<   %tmp69 = load i8* %filler63.4.1, align 1
<   %filler63.4.2 = getelementptr inbounds [3 x i8]* %filler63.4, i32 0, i32 2
<   %tmp70 = load i8* %filler63.4.2, align 1
<   %filler63.5 = getelementptr inbounds %struct.two* %filler63, i32 0, i32 5
<   %tmp67 = load i8* %filler63.5, align 4
<   %conv7 = sext i8 %tmp67 to i32
>   %3 = bitcast %struct.two* %test_two to i8*
>   %4 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 16, i32 4, i1 false)
>   %c6 = getelementptr inbounds %struct.two* %test_two, i32 0, i32 5
>   %5 = load i8* %c6, align 1
>   %conv7 = sext i8 %5 to i32
95,105c79,84
<   %filler58 = bitcast [16 x i8]* %filler to %struct.three*
<   %filler58.0 = getelementptr inbounds %struct.three* %filler58, i32 0, i32 0
<   %tmp59 = load i16* %filler58.0, align 2
<   %filler58.1 = getelementptr inbounds %struct.three* %filler58, i32 0, i32 1
<   %filler58.1.0 = getelementptr inbounds [2 x i8]* %filler58.1, i32 0, i32 0
<   %tmp61 = load i8* %filler58.1.0, align 2
<   %filler58.1.1 = getelementptr inbounds [2 x i8]* %filler58.1, i32 0, i32 1
<   %tmp62 = load i8* %filler58.1.1, align 1
<   %filler58.2 = getelementptr inbounds %struct.three* %filler58, i32 0, i32 2
<   %tmp60 = load i8* %filler58.2, align 2
<   %bf.clear = and i8 %tmp60, 127
>   %6 = bitcast %struct.three* %test_three to i8*
>   %7 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 6, i32 2, i1 false)
>   %c13 = getelementptr inbounds %struct.three* %test_three, i32 0, i32 2
>   %bf.load = load i8* %c13, align 2
>   %bf.clear = and i8 %bf.load, 127
116,136c95,100
<   %filler48 = bitcast [16 x i8]* %filler to %struct.four*
<   %filler55 = bitcast [16 x i8]* %filler to [2 x i8]*
<   %filler55.0 = getelementptr inbounds [2 x i8]* %filler55, i32 0, i32 0
<   %tmp56 = load i8* %filler55.0, align 4
<   %filler55.1 = getelementptr inbounds [2 x i8]* %filler55, i32 0, i32 1
<   %tmp57 = load i8* %filler55.1, align 1
<   %filler48.1 = getelementptr inbounds %struct.four* %filler48, i32 0, i32 1
<   %filler48.1.0 = getelementptr inbounds [2 x i8]* %filler48.1, i32 0, i32 0
<   %tmp53 = load i8* %filler48.1.0, align 2
<   %filler48.1.1 = getelementptr inbounds [2 x i8]* %filler48.1, i32 0, i32 1
<   %tmp54 = load i8* %filler48.1.1, align 1
<   %filler48.2 = getelementptr inbounds %struct.four* %filler48, i32 0, i32 2
<   %tmp49 = load i8* %filler48.2, align 4
<   %filler48.3 = getelementptr inbounds %struct.four* %filler48, i32 0, i32 3
<   %filler48.3.0 = getelementptr inbounds [3 x i8]* %filler48.3, i32 0, i32 0
<   %tmp50 = load i8* %filler48.3.0, align 1
<   %filler48.3.1 = getelementptr inbounds [3 x i8]* %filler48.3, i32 0, i32 1
<   %tmp51 = load i8* %filler48.3.1, align 1
<   %filler48.3.2 = getelementptr inbounds [3 x i8]* %filler48.3, i32 0, i32 2
<   %tmp52 = load i8* %filler48.3.2, align 1
<   %bf.clear22 = and i8 %tmp49, 127
>   %8 = bitcast %struct.four* %test_four to i8*
>   %9 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 8, i32 4, i1 false)
>   %c20 = getelementptr inbounds %struct.four* %test_four, i32 0, i32 2
>   %bf.load21 = load i8* %c20, align 4
>   %bf.clear22 = and i8 %bf.load21, 127
147,154c111,116
<   %filler44 = bitcast [16 x i8]* %filler to %struct.five*
<   %filler44.0 = getelementptr inbounds %struct.five* %filler44, i32 0, i32 0
<   %tmp45 = load i8* %filler44.0, align 1
<   %filler44.1 = getelementptr inbounds %struct.five* %filler44, i32 0, i32 1
<   %tmp46 = load i8* %filler44.1, align 1
<   %filler44.2 = getelementptr inbounds %struct.five* %filler44, i32 0, i32 2
<   %tmp47 = load i8* %filler44.2, align 1
<   %conv30 = sext i8 %tmp47 to i32
>   %10 = bitcast %struct.five* %test_five to i8*
>   %11 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 3, i32 1, i1 false)
>   %c29 = getelementptr inbounds %struct.five* %test_five, i32 0, i32 2
>   %12 = load i8* %c29, align 1
>   %conv30 = sext i8 %12 to i32
164,183c126,131
<   %filler35 = bitcast [16 x i8]* %filler to %struct.six*
<   %filler35.0 = getelementptr inbounds %struct.six* %filler35, i32 0, i32 0
<   %tmp36 = load i8* %filler35.0, align 4
<   %filler35.1 = getelementptr inbounds %struct.six* %filler35, i32 0, i32 1
<   %filler35.1.0 = getelementptr inbounds [3 x i8]* %filler35.1, i32 0, i32 0
<   %tmp41 = load i8* %filler35.1.0, align 1
<   %filler35.1.1 = getelementptr inbounds [3 x i8]* %filler35.1, i32 0, i32 1
<   %tmp42 = load i8* %filler35.1.1, align 1
<   %filler35.1.2 = getelementptr inbounds [3 x i8]* %filler35.1, i32 0, i32 2
<   %tmp43 = load i8* %filler35.1.2, align 1
<   %filler35.2 = getelementptr inbounds %struct.six* %filler35, i32 0, i32 2
<   %tmp37 = load i8* %filler35.2, align 4
<   %filler35.3 = getelementptr inbounds %struct.six* %filler35, i32 0, i32 3
<   %tmp38 = load i8* %filler35.3, align 1
<   %filler35.4 = getelementptr inbounds %struct.six* %filler35, i32 0, i32 4
<   %filler35.4.0 = getelementptr inbounds [2 x i8]* %filler35.4, i32 0, i32 0
<   %tmp39 = load i8* %filler35.4.0, align 2
<   %filler35.4.1 = getelementptr inbounds [2 x i8]* %filler35.4, i32 0, i32 1
<   %tmp40 = load i8* %filler35.4.1, align 1
<   %conv37 = sext i8 %tmp38 to i32
>   %13 = bitcast %struct.six* %test_six to i8*
>   %14 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 4, i1 false)
>   %c36 = getelementptr inbounds %struct.six* %test_six, i32 0, i32 3
>   %15 = load i8* %c36, align 1
>   %conv37 = sext i8 %15 to i32
193,200c141,146
<   %filler31 = bitcast [16 x i8]* %filler to %struct.seven*
<   %filler31.0 = getelementptr inbounds %struct.seven* %filler31, i32 0, i32 0
<   %tmp32 = load i8* %filler31.0, align 1
<   %filler31.1 = getelementptr inbounds %struct.seven* %filler31, i32 0, i32 1
<   %tmp33 = load i8* %filler31.1, align 1
<   %filler31.2 = getelementptr inbounds %struct.seven* %filler31, i32 0, i32 2
<   %tmp34 = load i8* %filler31.2, align 1
<   %conv44 = sext i8 %tmp34 to i32
>   %16 = bitcast %struct.seven* %test_seven to i8*
>   %17 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %17, i64 3, i32 1, i1 false)
>   %c43 = getelementptr inbounds %struct.seven* %test_seven, i32 0, i32 2
>   %18 = load i8* %c43, align 1
>   %conv44 = sext i8 %18 to i32
210,219c156,161
<   %filler26 = bitcast [16 x i8]* %filler to %struct.eight*
<   %filler26.0 = getelementptr inbounds %struct.eight* %filler26, i32 0, i32 0
<   %tmp27 = load i8* %filler26.0, align 2
<   %filler26.1 = getelementptr inbounds %struct.eight* %filler26, i32 0, i32 1
<   %tmp28 = load i8* %filler26.1, align 1
<   %filler26.2 = getelementptr inbounds %struct.eight* %filler26, i32 0, i32 2
<   %tmp29 = load i8* %filler26.2, align 2
<   %filler26.3 = getelementptr inbounds %struct.eight* %filler26, i32 0, i32 3
<   %tmp30 = load i8* %filler26.3, align 1
<   %conv51 = sext i8 %tmp29 to i32
>   %19 = bitcast %struct.eight* %test_eight to i8*
>   %20 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 4, i32 2, i1 false)
>   %c50 = getelementptr inbounds %struct.eight* %test_eight, i32 0, i32 2
>   %21 = load i8* %c50, align 1
>   %conv51 = sext i8 %21 to i32
229,247c171,176
<   %filler17 = bitcast [16 x i8]* %filler to %union.nine*
<   %filler17.0 = getelementptr inbounds %union.nine* %filler17, i32 0, i32 0
<   %tmp18 = load i8* %filler17.0, align 8
<   %filler17.1 = getelementptr inbounds %union.nine* %filler17, i32 0, i32 1
<   %filler17.1.0 = getelementptr inbounds [7 x i8]* %filler17.1, i32 0, i32 0
<   %tmp19 = load i8* %filler17.1.0, align 1
<   %filler17.1.1 = getelementptr inbounds [7 x i8]* %filler17.1, i32 0, i32 1
<   %tmp20 = load i8* %filler17.1.1, align 1
<   %filler17.1.2 = getelementptr inbounds [7 x i8]* %filler17.1, i32 0, i32 2
<   %tmp21 = load i8* %filler17.1.2, align 1
<   %filler17.1.3 = getelementptr inbounds [7 x i8]* %filler17.1, i32 0, i32 3
<   %tmp22 = load i8* %filler17.1.3, align 1
<   %filler17.1.4 = getelementptr inbounds [7 x i8]* %filler17.1, i32 0, i32 4
<   %tmp23 = load i8* %filler17.1.4, align 1
<   %filler17.1.5 = getelementptr inbounds [7 x i8]* %filler17.1, i32 0, i32 5
<   %tmp24 = load i8* %filler17.1.5, align 1
<   %filler17.1.6 = getelementptr inbounds [7 x i8]* %filler17.1, i32 0, i32 6
<   %tmp25 = load i8* %filler17.1.6, align 1
<   %conv58 = sext i8 %tmp18 to i32
>   %22 = bitcast %union.nine* %test_nine to i8*
>   %23 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %23, i64 8, i32 8, i1 false)
>   %c57 = bitcast %union.nine* %test_nine to i8*
>   %24 = load i8* %c57, align 1
>   %conv58 = sext i8 %24 to i32
257,292c186,191
<   %filler1 = bitcast [16 x i8]* %filler to %struct.ten*
<   %filler1.0 = getelementptr inbounds %struct.ten* %filler1, i32 0, i32 0
<   %tmp = load i8* %filler1.0, align 8
<   %filler1.1 = getelementptr inbounds %struct.ten* %filler1, i32 0, i32 1
<   %filler1.1.0 = getelementptr inbounds [7 x i8]* %filler1.1, i32 0, i32 0
<   %tmp10 = load i8* %filler1.1.0, align 1
<   %filler1.1.1 = getelementptr inbounds [7 x i8]* %filler1.1, i32 0, i32 1
<   %tmp11 = load i8* %filler1.1.1, align 1
<   %filler1.1.2 = getelementptr inbounds [7 x i8]* %filler1.1, i32 0, i32 2
<   %tmp12 = load i8* %filler1.1.2, align 1
<   %filler1.1.3 = getelementptr inbounds [7 x i8]* %filler1.1, i32 0, i32 3
<   %tmp13 = load i8* %filler1.1.3, align 1
<   %filler1.1.4 = getelementptr inbounds [7 x i8]* %filler1.1, i32 0, i32 4
<   %tmp14 = load i8* %filler1.1.4, align 1
<   %filler1.1.5 = getelementptr inbounds [7 x i8]* %filler1.1, i32 0, i32 5
<   %tmp15 = load i8* %filler1.1.5, align 1
<   %filler1.1.6 = getelementptr inbounds [7 x i8]* %filler1.1, i32 0, i32 6
<   %tmp16 = load i8* %filler1.1.6, align 1
<   %filler1.2 = getelementptr inbounds %struct.ten* %filler1, i32 0, i32 2
<   %tmp2 = load i8* %filler1.2, align 8
<   %filler1.3 = getelementptr inbounds %struct.ten* %filler1, i32 0, i32 3
<   %filler1.3.0 = getelementptr inbounds [7 x i8]* %filler1.3, i32 0, i32 0
<   %tmp3 = load i8* %filler1.3.0, align 1
<   %filler1.3.1 = getelementptr inbounds [7 x i8]* %filler1.3, i32 0, i32 1
<   %tmp4 = load i8* %filler1.3.1, align 1
<   %filler1.3.2 = getelementptr inbounds [7 x i8]* %filler1.3, i32 0, i32 2
<   %tmp5 = load i8* %filler1.3.2, align 1
<   %filler1.3.3 = getelementptr inbounds [7 x i8]* %filler1.3, i32 0, i32 3
<   %tmp6 = load i8* %filler1.3.3, align 1
<   %filler1.3.4 = getelementptr inbounds [7 x i8]* %filler1.3, i32 0, i32 4
<   %tmp7 = load i8* %filler1.3.4, align 1
<   %filler1.3.5 = getelementptr inbounds [7 x i8]* %filler1.3, i32 0, i32 5
<   %tmp8 = load i8* %filler1.3.5, align 1
<   %filler1.3.6 = getelementptr inbounds [7 x i8]* %filler1.3, i32 0, i32 6
<   %tmp9 = load i8* %filler1.3.6, align 1
<   %conv65 = sext i8 %tmp2 to i32
>   %25 = bitcast %struct.ten* %test_ten to i8*
>   %26 = bitcast [16 x i8]* %filler to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 16, i32 8, i1 false)
>   %c64 = getelementptr inbounds %struct.ten* %test_ten, i32 0, i32 2
>   %27 = load i8* %c64, align 1
>   %conv65 = sext i8 %27 to i32
	G Log Pass
 	G Out Pass
 PR10189.c:79:11: warning: too few arguments in call to 'func_1'
  func_1 ();
  ~~~~~~  ^
PR10189.c:34:5: warning: tentative array definition assumed to have one element
int g_20[][1][0];
    ^
PR10189.c:42:11: warning: tentative array definition assumed to have one element
struct S2 g_1639[];
          ^
3 warnings generated.
===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

 2 mem2reg    - Number of PHI nodes inserted
17 mem2reg    - Number of alloca's promoted with a single store
 4 scalarrepl - Number of allocas broken up
19 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

 2 mem2reg    - Number of PHI nodes inserted
16 mem2reg    - Number of alloca's promoted with a single store
 2 scalarrepl - Number of aggregate allocas broken up
18 scalarrepl - Number of scalar allocas promoted to register

Diffing(PR10189) 
50a51
>   %retval = alloca %struct.S2, align 4
63,66c64,69
<   %g_16391 = bitcast [1 x %struct.S2]* @g_1639 to %struct.S0*
<   %g_16391.0 = getelementptr inbounds %struct.S0* %g_16391, i32 0, i32 0
<   %tmp = load i32* %g_16391.0, align 1
<   ret i32 %tmp
>   %1 = bitcast %struct.S2* %retval to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ([1 x %struct.S2]* @g_1639 to i8*), i64 4, i32 1, i1 false)
>   %coerce.dive = getelementptr %struct.S2* %retval, i32 0, i32 0
>   %coerce.dive2 = getelementptr %struct.S0* %coerce.dive, i32 0, i32 0
>   %2 = load i32* %coerce.dive2
>   ret i32 %2
155a159,160
>   %0 = alloca %struct.S0
>   %coerce = alloca %struct.S2, align 4
	G Log Pass
 	G Out Pass
 PR1386.c:15:9: warning: implicit truncation from 'int' to bitfield changes value from 255 to 15 [-Wbitfield-constant-conversion]
  x.pad = 255;
        ^ ~~~
PR1386.c:17:7: warning: implicit truncation from 'unsigned long long' to bitfield changes value from 18446744073709551615 to 1152921504606846975 [-Wbitfield-constant-conversion]
  x.b = -1ULL;
      ^ ~~~~~
PR1386.c:20:30: warning: format specifies type 'unsigned long long' but the argument has type 'uint64_t' (aka 'unsigned long') [-Wformat]
  printf("bad bits: %llx\n", bad_bits);
                    ~~~~     ^~~~~~~~
                    %lx
3 warnings generated.
===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

2 mem2reg    - Number of alloca's promoted with a single store
1 mem2reg    - Number of alloca's promoted within one block
1 scalarrepl - Number of aggregates converted to scalar
3 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

2 mem2reg    - Number of alloca's promoted with a single store
2 scalarrepl - Number of scalar allocas promoted to register

Diffing(PR1386) 
4a5,6
> %struct.X = type <{ [16 x i8] }>
> 
10c12,15
>   %x = alloca %struct.X, align 1
>   %0 = bitcast %struct.X* %x to i128*
>   %bf.load = load i128* %0, align 1
12c17,20
>   store i128 %bf.set, i128* %0, align 1
>   %1 = bitcast %struct.X* %x to i128*
>   %bf.load1 = load i128* %1, align 1
14c22,25
<   %bf.clear5 = and i128 %bf.set3, 295147905179352825855
>   store i128 %bf.set3, i128* %1, align 1
>   %2 = bitcast %struct.X* %x to i128*
>   %bf.load4 = load i128* %2, align 1
>   %bf.clear5 = and i128 %bf.load4, 295147905179352825855
16,18c27,31
<   %0 = lshr i128 %bf.set6, 64
<   %1 = trunc i128 %0 to i64
>   store i128 %bf.set6, i128* %2, align 1
>   %3 = bitcast %struct.X* %x to i64*
>   %add.ptr = getelementptr inbounds i64* %3, i64 1
>   %4 = load i64* %add.ptr, align 8
	G Log Pass
 	G Out Pass
 uint64_to_float.c:82:42: warning: format specifies type 'unsigned long long' but the argument has type 'uint64_t' (aka 'unsigned long') [-Wformat]
                printf("Error detected @ 0x%016llx\n", x);
                                           ~~~~~~~     ^
                                           %016lx
1 warning generated.
===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

11 mem2reg    - Number of PHI nodes inserted
11 mem2reg    - Number of alloca's promoted with a single store
 3 scalarrepl - Number of aggregates converted to scalar
 3 scalarrepl - Number of allocas broken up
19 scalarrepl - Number of allocas promoted

===-------------------------------------------------------------------------===
                          ... Statistics Collected ...
===-------------------------------------------------------------------------===

11 mem2reg    - Number of PHI nodes inserted
 8 mem2reg    - Number of alloca's promoted with a single store
16 scalarrepl - Number of scalar allocas promoted to register

Diffing(uint64_to_float) 
4a5,6
> %union.float_bits = type { i32 }
> 
19a22
>   %fb = alloca %union.float_bits, align 4
98c101,104
<   %1 = bitcast i32 %or29 to float
>   %u = bitcast %union.float_bits* %fb to i32*
>   store i32 %or29, i32* %u, align 4
>   %f = bitcast %union.float_bits* %fb to float*
>   %1 = load float* %f, align 4
111a118,120
>   %expected = alloca %union.float_bits, align 4
>   %observed = alloca %union.float_bits, align 4
>   %f = bitcast %union.float_bits* %expected to float*
113c122,123
<   %0 = bitcast float %call to i32
>   store float %call, float* %f, align 4
>   %f1 = bitcast %union.float_bits* %observed to float*
115c125,129
<   %1 = bitcast float %conv to i32
>   store float %conv, float* %f1, align 4
>   %u = bitcast %union.float_bits* %expected to i32*
>   %0 = load i32* %u, align 4
>   %u2 = bitcast %union.float_bits* %observed to i32*
>   %1 = load i32* %u2, align 4
<   %2 = bitcast i32 %0 to float
>   %f5 = bitcast %union.float_bits* %expected to float*
>   %2 = load float* %f5, align 4
123,126c138,146
<   %call8 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([31 x i8]* @.str1, i32 0, i32 0), double %conv6, i32 %0)
<   %3 = bitcast i32 %1 to float
<   %conv10 = fpext float %3 to double
<   %call12 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([31 x i8]* @.str2, i32 0, i32 0), double %conv10, i32 %1)
>   %u7 = bitcast %union.float_bits* %expected to i32*
>   %3 = load i32* %u7, align 4
>   %call8 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([31 x i8]* @.str1, i32 0, i32 0), double %conv6, i32 %3)
>   %f9 = bitcast %union.float_bits* %observed to float*
>   %4 = load float* %f9, align 4
>   %conv10 = fpext float %4 to double
>   %u11 = bitcast %union.float_bits* %observed to i32*
>   %5 = load i32* %u11, align 4
>   %call12 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([31 x i8]* @.str2, i32 0, i32 0), double %conv10, i32 %5)
	G Log Pass
 	G Out Pass
 